# 信号：基本概念

## 概念和概述

信号是事件发生时对进程的通知机制。有时也称之为软件中断。信号与硬件中断的相似
之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号到达的精确时间。

一个（具有合适权限的）进程能够向另一进程发送信号。信号的这一用法可作为一种同
步技术，甚至是进程间通信（IPC）的原始形式。进程也可以向自身发送信号。然而，发往进
程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下。
1. 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号
给相关进程。硬件异常的例子包括执行一条异常的机器语言指令，诸如，被 0 除，或
者引用了无法访问的内存区域。
2. 用户键入了能够产生信号的终端特殊字符。其中包括中断字符（通常是 Control-C)、
暂停字符（通常是 Control-Z）。
3. 发生了软件事件。例如，针对文件描述符的输出变为有效，调整了终端窗口大小，定
时器到期，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。

信号分为两大类。
1. 用于内核向进程通知事件，构成所谓的传统信号（标准信号）。
2. 实时信号。

通常情况下一旦内核接下来要调度该进程运行，等待信号会马上送达（或者进程正在运行，会立刻传递信号）。

有时为了确保代码不被传递来的信号打断，可以将信号添加到添加到***进程的信号掩码当中*** ------ 会阻塞这组信号的到达

倘若这组信号属于阻塞之列，那么信号将保持等待状态，直至稍后对其进行解除阻塞（从信号掩码当中移除）
进程可以使用各种系统调用对其信号掩码添加和移除信号。

信号到达后，进程视具体信号执行如下默认操作之一
1. 忽略信号：内核将信号丢弃，进程不做任何响应。这在某些情况下可能会有用，例如，进程可能对某些信号不感兴趣或者对它们进行了特殊处理。

2. 终止进程：有时是指进程异常终止，而不是通过调用exit()函数正常退出。这通常发生在进程遇到致命错误或者收到类似SIGKILL这样的信号时。进程会立即停止执行并退出。

3. 产生核心转储文件，同时停止进程：当进程收到像SIGSEGV（段错误）这样的信号时，操作系统会将进程的当前内存映像保存到核心转储文件中。这个文件可以用于调试，开发人员可以在发生错误时检查进程的状态。

4. 停止进程：暂停进程的执行，但不会终止它。这通常是通过发送SIGSTOP信号来实现的。停止后的进程可以通过发送SIGCONT信号来恢复执行。

5. 于之前暂停后再度恢复进程的执行：如果进程之前被暂停（通过发送SIGSTOP信号），它可以通过发送SIGCONT信号来继续执行。这对于暂时停止进程然后再次启动它是很有用的。


除了根据特定信号采取的默认行为，程序也能改变信号到达时的响应行为。
称之为**对信号的处置设置**。程序可以将对信号的处置设置为如下之一
1. 采取默认行为。适用于撤销信号之前对信号处置的设置
2. 忽略信号。适用于默认行为为终止进程的信号
3. 执行信号处理器程序


信号处理器程序是由程序员编写的函数，用于为响应传递来的信号而执行适当任务。例
如，shell 为 SIGINT 信号（由中断字符串 Control-C 产生）提供了一个处理器程序，令其停止
当前正在执行的工作，并将控制返回到（shell 的）主输入循环，并再次向用户呈现 shell 提示符。
通知内核应当去调用某一处理器程序的行为，通常称之为安装或者建立信号处理器程序。调
用信号处理器程序以响应传递来的信号，则称之为信号已处理（handled），或者已捕获（caught）。

无法将信号处置设置为终止进程或者转储核心（除非这是对信号的默认处置）。
效果最为近似的是为信号安装一个处理器程序，并于其中调用 exit()或者 abort()。
abort()为进程产生一个 SIGABRT 信号，该信号将引发进程转储核心文件并终止。

## 信号类型和默认行为

SIGHUP (1)：

解释：SIGHUP是“Hangup”的缩写，意味着终端挂起或控制进程终止。通常在用户退出终端会话时发送给与终端相关的进程，以通知它们终端会话已经结束。

SIGINT (2)：

解释：SIGINT是“Interrupt”的缩写，用于中断正在运行的进程。通常由用户在终端按下Ctrl+C键触发，以向当前运行的进程发送中断信号，请求其终止执行。

SIGQUIT (3)：

解释：SIGQUIT是“Quit”的缩写，用于终止进程并生成核心转储文件。通常由用户在终端按下Ctrl+\键触发，与SIGINT类似，但会导致进程生成核心转储文件，以便进一步调试。

SIGILL (4)：

解释：SIGILL表示进程执行了非法指令，通常表示进程遇到了无效的机器指令。

SIGTRAP (5)：

解释：SIGTRAP表示跟踪/断点陷阱，通常由调试器用于在进程执行时设置断点或跟踪。

SIGABRT (6)：

解释：SIGABRT表示异常终止请求，通常由abort()函数生成，用于请求进程异常终止并生成核心转储文件。

SIGBUS (7)：

解释：SIGBUS表示进程遇到了总线错误，通常是由于对未对齐内存地址进行读写操作而引起的。

SIGFPE (8)：

解释：SIGFPE表示浮点异常，通常是由于对浮点运算中的非法操作（如除以零）而引起的。

SIGKILL (9)：

解释：SIGKILL是一个无条件终止信号，不能被捕获或忽略，用于强制结束一个进程。

SIGUSR1 (10)：

解释：SIGUSR1和SIGUSR2是两个用户自定义信号，通常由用户程序用于向进程发送自定义通知或命令。

SIGSEGV (11)：

解释：SIGSEGV表示进程尝试访问未分配给它的内存地址，通常称为段错误。

SIGUSR2 (12)：

解释：见SIGUSR1。

SIGPIPE (13)：

解释：SIGPIPE表示管道破裂，通常发生在进程尝试向一个已关闭的管道写入数据时。

SIGALRM (14)：

解释：SIGALRM表示定时器超时，通常用于向进程发送定时提醒或触发操作。

SIGTERM (15)：

解释：SIGTERM是正常终止请求，通常由kill命令或操作系统发出，请求进程正常终止。

SIGSTKFLT (16)：

解释：SIGSTKFLT表示协处理器栈错误。

SIGCHLD (17)：

解释：SIGCHLD表示子进程状态发生改变，通常由操作系统向父进程发送，以通知子进程的终止或停止。

SIGCONT (18)：

解释：SIGCONT表示继续执行已停止的进程，通常由kill命令发送给已暂停的进程，以请求其继续执行。

SIGSTOP (19)：

解释：SIGSTOP用于停止执行进程，类似于SIGKILL，但可以被其他信号（如SIGCONT）重新启动。

SIGTSTP (20)：

解释：SIGTSTP表示停止进程，通常由用户按下Ctrl+Z键触发，将当前运行的进程暂停，并将其置于后台。

SIGTTIN (21)：

解释：SIGTTIN表示后台进程尝试读取控制终端。

SIGTTOU (22)：

解释：SIGTTOU表示后台进程尝试写入控制终端。

SIGURG (23)：

解释：SIGURG表示套接字外带数据可用或紧急情况。

SIGXCPU (24)：

解释：SIGXCPU表示CPU时间限制已超过。

SIGXFSZ (25)：

解释：SIGXFSZ表示文件大小限制已超过。

SIGVTALRM (26)：

解释：SIGVTALRM表示虚拟定时器超时。

SIGPROF (27)：

解释：SIGPROF表示定时器超时。

SIGWINCH (28)：

解释：SIGWINCH表示窗口大小调整。

SIGIO (29)：

解释：SIGIO表示异步I/O事件发生。

SIGPWR (30)：

解释：SIGPWR表示电源故障。

SIGSYS (31)：

解释：SIGSYS表示非法系统调用。


## 改变信号处置：signal()

```c
#include <signal.h>

void ( *signal(int sig, void (*handler)(int)) ) (int);
```

在为 signal()指定 handler 参数时，可以以如下值来代替函数地址：
SIG_DFL 
将信号处置重置为默认值。这适用于将之前 signal()调用所改变的信号处置
还原。
SIG_IGN 
忽略该信号。如果信号专为此进程而生，那么内核会默默将其丢弃。进程甚至从未知道
曾经产生了该信号。
调用 signal()成功将返回先前的信号处置，有可能是先前安装的处理器函数地址，也可能
是常量 SIG_DFL 和 SIG_IGN 之一。如果调用失败，signal()将返回 SIG_ERR。

## 信号处理器简介

信号处理器程序（也称为信号捕捉器）是当指定信号传递给进程时将会调用的一个函数。
调用信号处理器程序，可能会随时打断主程序流程；内核代表进程来调用处理器程序，
当处理器返回时，主程序会在处理器打断的位置恢复执行。
```c
#include "tlpi_hdr.h"
#include <signal.h>

static void sigHandler(int sig) {
    static int count = 0;
    if (sig == SIGINT) {
        printf("Caught SIGINT (%d)\n", count);
    }

    printf("Caught SIGQUIT - that's all folks\n");

    exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[]) {
    if (signal(SIGINT, sigHandler) == SIG_ERR) {
        errExit("signal");
    }

    if (signal(SIGQUIT, sigHandler) == SIG_ERR) {
        errExit("signal");
    }

    for (;;) {
        pause();
    }
}
```

## 发送信号：kill()

与 shell 的 kill 命令相类似，一个进程能够使用 kill()系统调用向另一进程发送信号。

```c
#include <signal.h>

int kill(pid_t pid,int sig);

//return 0 on success, or -1 on error
```

pid 参数标识一个或多个目标进程，而 sig 则指定了要发送的信号。如何解释 pid，要视以下 4 种情况而定。
如果 pid 大于 0，那么会发送信号给由 pid 指定的进程。
如果 pid 等于 0，那么会发送信号给与调用进程同组的每个进程，包括调用进程自身。
如果 pid 小于−1，那么会向组 ID 等于该 pid 绝对值的进程组内所有下属进程发送
信号。向一个进程组的所有进程发送信号在 shell 作业控制中有特殊用途。
如果 pid 等于−1，那么信号的发送范围是：调用进程有权将信号发往的每个目标进程，
除去 init（进程 ID 为 1）和调用进程自身。如果特权级进程发起这一调用，那么会发
送信号给系统中的所有进程，上述两个进程除外。显而易见，有时也将这种信号发送
方式称之为广播信号。

如果并无进程与指定的 pid 相匹配，那么 kill()调用失败，同时将 errno 置为 ESRCH（“查无此进程”）。
进程要发送信号给另一进程，还需要适当的权限，其权限规则如下。
特权级（CAP_KILL）进程可以向任何进程发送信号。
以 root 用户和组运行的 init 进程（进程号为 1），是一种特例，仅能接收已安装了处理
器函数的信号。这可以防止系统管理员意外杀死 init 进程—这一系统运作的基石。
如图 20-2 所示，如果发送者的实际或有效用户 ID 匹配于接受者的实际用户 ID 或者
保存设置用户 ID(saved set-user-id)，那么非特权进程也可以向另一进程发送信号。利
用这一规则，用户可以向由他们启动的 set-user-ID 程序发送信号，而无需考虑目标进程
有效用户 ID 的当前设置。将目标进程有效用户 ID 排除在检查范围之外，这一举措的辅
助作用在于防止用户某甲向用户某乙的进程发送信号，而该进程正在执行的 set-user-ID
程序又属于用户某甲。
SIGCONT 信号需要特殊处理。无论对用户 ID 的检查结果如何，非特权进程可以向同
一会话中的任何其他进程发送这一信号。利用这一规则，运行作业控制的 shell 可以重
启已停止的作业（进程组），即使作业进程已经修改了它们的用户 ID。

如果进程无权发送信号给所请求的 pid，那么 kill()调用将失败，且将 errno 置为 EPERM。若 pid
所指为一系列进程（即 pid 是负值）时，只要可以向其中之一发送信号，则 kill()调用成功。

```c
#include "tlpi_hdr.h"
#include <signal.h>

int main(int argc, char *argv[]) {
    int s, sig;

    if (argc != 3 || strcmp(argv[1], "--help") == 0) {
        usageErr("%s sig-num pid\n", argv[0]);
    }

    sig = getInt(argv[2], 0, "sig-num");

    s = kill(getLong(argv[1], 0, "pid"), sig);

    if (sig != 0) {
        if (s == -1) {
            errExit("kill");
        }
    } else {
        if (s == 0) {
            printf("Process exists and we can send it a signal\n");
        } else {
            if (errno == EPERM) {
                printf("Process exists, but we don't have"
                       "Permission to send i a signal\n");
            } else if (errno == ESRCH) {
                printf("Process dose not exist\n");
            } else {
                errExit("kill");
            }
        }
    }
    exit(EXIT_SUCCESS);
}
```

## 检查进程的存在

kill()系统调用还有另一重功用。若将参数 sig 指定为 0（即所谓空信号），则无信号发送。
相反，kill()仅会去执行错误检查，查看是否可以向目标进程发送信号。从另一角度来看，这
意味着，可以使用空信号来检测具有特定进程 ID 的进程是否存在。若发送空信号失败，且 errno
为 ESRCH，则表明目标进程不存在。如果调用失败，且 errno 为 EPERM（表示进程存在，但
无权向目标进程发送信号）或者调用成功（有权向进程发送信号），那么就表示进程存在。

此外，还可使用各种其他技术来检查某一特定进程是否正在运行：

1. wait()系统调用：这些调用仅用于监控调用者的子进程。
2. 信号量和排他文件锁：如果进程持续持有某一信号量或文件锁，并且一直处于被监控状态，那么如能获取到信号量或锁时，即表明该进程已经终止。
3. 诸如管道和 FIFO 之类的 IPC 通道：可对监控目标进程进行设置，令其在自身生命周期内持有对通道进行写操作的打开文件描述符。同时，令监控进程持有针对通道进行读操作的打开文件描述符，且当通道写入端关闭时（遭遇文件结束符），即可获知监控目标进程已经终止。
4. /proc/PID 接口：例如，如果进程 ID 为 12345 的进程存在，那么目录/proc/12345 将存在，可以发起诸如 stat()之类的调用来进行检查。


除去最后一项之外，循环使用进程 ID 不会影响上述所有技术。

## 发送信号的其他方式：raise()  killpg()

有时，进程需要向自身发送信号。raise()函数就执行了这一任务。
```c
#include <signal.h>

int raise(int sig);

//Return 0 on success,or nonzero on error
```

在单线程程序中，调用 raise()相当于对 kill()的如下调用：
```c
kill(get(pid), sig);
```
支持线程的系统会将 raise(sig)实现为：
```c
pthread_kill(pthread_self(), sig);
```

该实现意味着将信号传递给调用raise()的特定线程。相比之下，kill(getpid(),sig)调用会发送一个信号给调用进程，并可将该信号传递给该进程的任意线程。

当进程使用 raise()（或者 kill()）向自身发送信号时，信号将立即传递（即，在 raise()返回调用者之前）

注意，raise()出错将返回非 0 值（不一定为–1）。调用 raise()唯一可能发生的错误为 EINVAL，即 sig 无效。因此，在任何指定了某一 SIGxxxx 常量的位置，都未检查该函数的返回状态。

killpg()函数向某一进程组的所有成员发送一个信号。
```c
#include <signal.h>

int killpg(pid_ pgrp. int sig);

//Return 0 on success,or -1 on error
```

killpg()调用相当于对 kill()的如下调用：
```c
kill(-pgrp,sig);
```
如果指定 pgrp 的值为 0，那么会向调用者所属进程组的所有进程发送此信号。

## 显示信号描述

每个信号都有一串与之相关的可打印说明。这些描述位于数组 sys_siglist 中。例如，可以
用 sys_siglist[SIGPIPE]来获取对 SIGPIPE 信号（管道断开）的描述。然而，较之于直接引用
sys_siglist 数组，还是推荐使用 strsignal()函数。
```c
#define _BSD_SOURCE
#include <signal.h>

// 声明一个数组以保存信号描述字符串
extern const char *const sys_siglist[];

#define _GUN_SOURCE
#include <string.h>

// 函数原型：获取信号的描述字符串
char *strsignal(int sig);

//Return pointer to signal description string
```

strsignal()函数对 sig 参数进行边界检查，然后返回一枚指针，指向针对该信号的可打印描
述字符串，或者是当信号编号无效时指向错误字符串。

除去边界检查之外，strsignal()函数较之于直接引用 sys_siglist 数组的另一优势是对本地（locale）设置敏感，所以显示信号描述时会使用本地语言。

psignal()函数（在标准错误设备上）所示为 msg 参数所给定的字符串，后面跟有一个冒号，
随后是对应于 sig 的信号描述。和 strsignal()一样，psignal()函数也对本地设置敏感。

```c
#include <signal.h>

void psignal(int sig, const char *msg);
```

## 信号集

许多信号相关的系统调用都需要能表示一组不同的信号。例如，sigaction()和 sigprocmask()
允许程序指定一组将由进程阻塞的信号，而 sigpending()则返回一组目前正在等待送达给一进程的信号。

多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。

sigemptyset()函数初始化一个未包含任何成员的信号集。sigfillset()函数则初始化一个信号
集，使其包含所有信号（包括所有实时信号）

```c
#include <signal.h>

int sigemptstyset(sigset_t *set);
int sigfillset(sigset_t *set);

//Both return 0 on success, or -1 on error
```
必须使用 sigemptyset()或者 sigfillset()来初始化信号集。这是因为 C 语言不会对自动变量进
行初始化，并且，借助于将静态变量初始化为 0 的机制来表示空信号集的作法在可移植性上
存在问题，因为有可能使用位掩码之外的结构来实现信号集。（出于同一原因，为将信号集标
记为空而使用 memset(3)函数将其内容清零的做法也不正确。

信号集初始化后，可以分别使用 sigaddset()和 sigdelset()函数向一个集合中添加或者移除
单个信号。

```c
#include <signal.h>

int sigaddset(sigset_t *set, int sig);
int sigdelset(sigset_t *set, int sig);

//Both return 0 on success, or -1 on error
```
在 sigaddset()和 sigdelset()中，sig 参数均表示信号编号。

sigismember()函数用来测试信号 sig 是否是信号集 set 的成员。
```c
#include <signal.h>

int sigismember(const sigset_t *set,int sig);

//Return 1 if sig is a member of set, otherwise 0
```
如果 sig 是 set 的一个成员，那么 sigismember()函数将返回 1（true），否则返回 0（false）

GNU C 库还实现了 3 个非标准函数，是对上述信号集标准函数的补充。
```c
#define _GUN_SOURCE
#include <signal.h>

int sigandset(sigset_t *set, sigset_t *left, sigset_t *right);
int sigorset(sigset_t *set, sigset_t *left, sigset_t *right);

//Both return 0 on success, or -1 on error

int sigisemptyset(const sigset_t *set);

//Return 1 if sig is empty, otherwise 0
```

这些函数执行了如下任务。
1. sigandset()将 left 集和 right 集的交集置于 dest 集。
2. sigorset()将 left 集和 right 集的并集置于 dest 集。
3. 若 set 集内未包含信号，则 sigisemptyset()返回 true。

### 示例程序

