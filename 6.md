# 进程

## 进程和程序

进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。

## 进程号和父进程号

每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。
对各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。
比如，系统调用 kill()允许调用者向拥有特定进程号的进程发送一个信号。
当需要创建一个对某进程而言唯一的标识符时，进程号就会派上用场。
常见的例子是将进程号作为与进程相关文件名的一部分。

系统调用 getpid()来获取进程的进程号
函数返回的值为pid_t类型，该类型专用于储存进程号。
同时，进程号存在上限，linux限制进程号需小于等于32767,当大于32767时，内核将重置计数器，以便继续分配。
另：内核重置计数器时，并非从1开始，而是从300开始，因为低数值的进程号为系统进程和守护进程所长期占用。

每个进程都有自己的父进程，可调用getppid()检索父进程号
每个进程的父进程号属性反映了系统上所有进程间的树状关系。
每个进程的父进程又有自己的父进程，
以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。

## 进程内存布局

每个进程所分配的内存由很多部分组成，通常称之为“ 段 ” 

文本段包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错
误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可
共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执
行文件中读取这些变量的值。

未初始化数据段包含了未进行显式初始化的全局变量和静态变量。程序启动之前，系统
将本段内所有内存初始化为 0。出于历史原因，此段常被称为 BSS 段，这源于老版本的
汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未经
初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必
要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位
置及所需大小，直到运行时再由程序加载器来分配这一空间。

栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。系统会为每个
当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实
参和返回值。

堆（heap）是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作program break。

程序变量在进程内存各段中的位置

```c
#include <stdio.h>
#include <stdlib.h>

char globBuf[65536];
int primes[] = {2, 3, 5, 7};
static int square(int x) {
    int result;
    result = x * x;
    return result;
}

static void doCalc(int val) {
    printf("The square of %d is %d\n", val, square(val));

    if (val < 1000) {
        int t;
        t = val * val * val;
        printf("The cube of %d is %d\n", val, t);
    }
}

int main(int argc, char *argv[]) {
    static int key = 9973;
    static char mbuf[10240000];
    char *p;
    
    p = malloc(1024);
    
    doCalc(key);

    exit(EXIT_SUCCESS);
}
```

## 虚拟内存管理

上述关于进程内存布局的讨论忽略了一个事实：这一布局存在于虚拟内存中。因为对虚
拟内存的理解将有助于后续对诸如 fork()系统调用、共享内存和映射文件之类主题的阐述，所
以这里将探讨一些有关虚拟内存的详细内容。

Linux，像多数现代内核一样，采用了虚拟内存管理技术。该技术利用了大多数程序的一
个典型特征，即访问局部性（locality of reference），以求高效使用 CPU 和 RAM（物理内存）资源。大多数程序都展现了两种类型的局部性。

空间局部性（Spatial locality）：是指程序倾向于访问在最近访问过的内存地址附近的
内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。

时间局部性（Temporal locality）：是指程序倾向于在不久的将来再次访问最近刚访问
过的内存地址（由于循环）。

正是由于访问局部性特征，使得程序即便仅有部分地址空间存在于 RAM 中，依然可能得
以执行。

虚拟内存的规划之一是将每个程序使用的内存切割成小型的、固定大小的“页”（page）
单元。相应地，将 RAM 划分成一系列与虚存页尺寸相同的页帧。任一时刻，每个程序仅有部
分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集（resident set）。程序未使用的页
拷贝保存在交换区（swap area）内—这是磁盘空间中的保留区域，作为计算机 RAM 的补充— 
仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在物理内存中，将会发生
页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。

为支持这一组织方式，内核需要为每个进程维护一张页表（page table）（见图 6-2）。该页
表描述了每页在进程虚拟地址空间（virtual address space）中的位置（可为进程所用的所有虚
拟内存页面的集合）。页表中的每个条目要么指出一个虚拟页面在 RAM 中的所在位置，要么
表明其当前驻留在磁盘上。

在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能
存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。若进程试
图访问的地址并无页表条目与之对应，那么进程将收到一个 SIGSEGV 信号。

## 栈和栈帧

函数的调用和返回使得栈的增长和收缩成线性，栈驻留在内存的高端并向下增长（堆的方向）。

栈指针----专用寄存器，用于跟踪栈顶，每次调用函数时，在栈上重新分配一帧，函数返回时，将此帧从栈上移除。

每个栈帧包含如下信息

1. 函数实参和局部变量：这些变量都是在调用函数时自动创建的，也称为自动变量。
函数返回时将自动销毁这些变量。

2. 函数调用的链接信息：每个函数都会用到cpu寄存器，如程序计数器，其指向下一条将要执行的及其语言指令。
每当一函数调用另一个函数时，会在被调用的函数的栈帧中保存这些寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复原状。

## 命令行参数

main()函数作为程序的起点，执行程序时，命令行参数通过两个入参提供给main函数。
1. int argc 表示命令行参数个数
2. char *argv[] 是一个指向命令行参数的指针数组，，每一个参数又是以空字符(NULL)结尾的字符串。
第一个字符串(argv[0])指向的通常为该程序的名称。
argv中的指针列表以NULL结尾(argv[argc]==NULL)

