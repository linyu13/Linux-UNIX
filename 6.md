# 进程

## 进程和程序

进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。

## 进程号和父进程号

每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。
对各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。
比如，系统调用 kill()允许调用者向拥有特定进程号的进程发送一个信号。
当需要创建一个对某进程而言唯一的标识符时，进程号就会派上用场。
常见的例子是将进程号作为与进程相关文件名的一部分。

系统调用 getpid()来获取进程的进程号
函数返回的值为pid_t类型，该类型专用于储存进程号。
同时，进程号存在上限，linux限制进程号需小于等于32767,当大于32767时，内核将重置计数器，以便继续分配。
另：内核重置计数器时，并非从1开始，而是从300开始，因为低数值的进程号为系统进程和守护进程所长期占用。

每个进程都有自己的父进程，可调用getppid()检索父进程号
每个进程的父进程号属性反映了系统上所有进程间的树状关系。
每个进程的父进程又有自己的父进程，
以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。

## 进程内存布局

每个进程所分配的内存由很多部分组成，通常称之为“ 段 ” 

文本段包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错
误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可
共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执
行文件中读取这些变量的值。

未初始化数据段包含了未进行显式初始化的全局变量和静态变量。程序启动之前，系统
将本段内所有内存初始化为 0。出于历史原因，此段常被称为 BSS 段，这源于老版本的
汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未经
初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必
要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位
置及所需大小，直到运行时再由程序加载器来分配这一空间。

栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。系统会为每个
当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实
参和返回值。

堆（heap）是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作program break。

程序变量在进程内存各段中的位置

```c
#include <stdio.h>
#include <stdlib.h>

char globBuf[65536];
int primes[] = {2, 3, 5, 7};
static int square(int x) {
    int result;
    result = x * x;
    return result;
}

static void doCalc(int val) {
    printf("The square of %d is %d\n", val, square(val));

    if (val < 1000) {
        int t;
        t = val * val * val;
        printf("The cube of %d is %d\n", val, t);
    }
}

int main(int argc, char *argv[]) {
    static int key = 9973;
    static char mbuf[10240000];
    char *p;
    
    p = malloc(1024);
    
    doCalc(key);

    exit(EXIT_SUCCESS);
}
```

## 虚拟内存管理

上述关于进程内存布局的讨论忽略了一个事实：这一布局存在于虚拟内存中。因为对虚
拟内存的理解将有助于后续对诸如 fork()系统调用、共享内存和映射文件之类主题的阐述，所
以这里将探讨一些有关虚拟内存的详细内容。

Linux，像多数现代内核一样，采用了虚拟内存管理技术。该技术利用了大多数程序的一
个典型特征，即访问局部性（locality of reference），以求高效使用 CPU 和 RAM（物理内存）资源。大多数程序都展现了两种类型的局部性。

空间局部性（Spatial locality）：是指程序倾向于访问在最近访问过的内存地址附近的
内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。

时间局部性（Temporal locality）：是指程序倾向于在不久的将来再次访问最近刚访问
过的内存地址（由于循环）。

正是由于访问局部性特征，使得程序即便仅有部分地址空间存在于 RAM 中，依然可能得
以执行。

虚拟内存的规划之一是将每个程序使用的内存切割成小型的、固定大小的“页”（page）
单元。相应地，将 RAM 划分成一系列与虚存页尺寸相同的页帧。任一时刻，每个程序仅有部
分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集（resident set）。程序未使用的页
拷贝保存在交换区（swap area）内—这是磁盘空间中的保留区域，作为计算机 RAM 的补充— 
仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在物理内存中，将会发生
页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。

为支持这一组织方式，内核需要为每个进程维护一张页表（page table）（见图 6-2）。该页
表描述了每页在进程虚拟地址空间（virtual address space）中的位置（可为进程所用的所有虚
拟内存页面的集合）。页表中的每个条目要么指出一个虚拟页面在 RAM 中的所在位置，要么
表明其当前驻留在磁盘上。

在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能
存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。若进程试
图访问的地址并无页表条目与之对应，那么进程将收到一个 SIGSEGV 信号。

## 栈和栈帧

函数的调用和返回使得栈的增长和收缩成线性，栈驻留在内存的高端并向下增长（堆的方向）。

栈指针----专用寄存器，用于跟踪栈顶，每次调用函数时，在栈上重新分配一帧，函数返回时，将此帧从栈上移除。

每个栈帧包含如下信息

1. 函数实参和局部变量：这些变量都是在调用函数时自动创建的，也称为自动变量。
函数返回时将自动销毁这些变量。

2. 函数调用的链接信息：每个函数都会用到cpu寄存器，如程序计数器，其指向下一条将要执行的及其语言指令。
每当一函数调用另一个函数时，会在被调用的函数的栈帧中保存这些寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复原状。

## 命令行参数

main()函数作为程序的起点，执行程序时，命令行参数通过两个入参提供给main函数。
1. int argc 表示命令行参数个数
2. char *argv[] 是一个指向命令行参数的指针数组，，每一个参数又是以空字符(NULL)结尾的字符串。
第一个字符串(argv[0])指向的通常为该程序的名称。
argv中的指针列表以NULL结尾(argv[argc]==NULL)

局限：仅对main函数可用，若想要在其它函数使用该参数，必须将argv以参数形式传递给其它函数，或者设置一个指向argv的全局变量

## 环境列表

每一个进程都有与之相关的称为环境列表的字符串数组(或简称为环境)。
其中每个字符串都以 名称=值 形式定义
因此，环境是“名称-值”的成对集合，可储存任意信息。
常将列表中的名称称为环境变量。

新进程在创建之时，会继承其父进程的环境副本。这是一种原始的进程间通信方式，却
颇为常用。环境（environment）提供了将信息从父进程传递给子进程的方法。由于子进程只
有在创建时才能获得其父进程的环境副本，所以这一信息传递是单向的、一次性的。子进程
创建后，父、子进程均可更改各自的环境变量，且这些变更对对方而言不再可见。

环境变量的常见用途之一是在 shell 中。通过在自身环境中放置变量值，shell 就可确保把
这些值传递给其所创建的进程，并以此来执行用户命令。

### 从程序中显示环境

```c
#include "tlpi_hdr.h"

extern char **environ;

int main(int argc, char *argv[]) {
    char **ep;

    for (ep = environ; *ep != NULL; ep++) {
        puts(*ep);
    }

    exit(EXIT_SUCCESS);
}
```

还可通过声明main函数中的第三个参数来访问环境变量
```c
int main(int argc, char *argv[], char *envp[])
```

该参数随即可被视为 environ 变量来使用，与上文所不同的是，该参数的作用域在 main()函数内。

### 修改环境

有时，对进程来说，修改其环境很有用处。原因之一是这一修改对该进程后续创建的所有子进
程均可见。另一个可能的原因在于设定某一变量，以求对于将要载入进程内存的新程序（“execed”）
可见。从这个意义上讲，环境不仅是一种进程间通信的形式，还是程序间通信的方法。

putenv()函数向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值。

参数 string 是一指针，指向 name=value 形式的字符串。调用 putenv()函数后，该字符串就
成为环境的一部分，换言之，putenv 函数将设定 environ 变量中某一元素的指向与 string 参
数的指向位置相同，而非 string 参数所指向字符串的复制副本。因此，如果随后修改 string 参
数所指的内容，这将影响该进程的环境。出于这一原因，string 参数不应为自动变量（即在栈
中分配的字符数组1），因为定义此变量的函数一旦返回，就有可能会重写这块内存区域。
putenv()函数调用失败将返回非 0 值，而非−1。

如果 string 参数内容不包含一个等
号（=），那么将从环境列表中移除以 string 参数命名的环境变量。
setenv()函数可以代替 putenv()函数，向环境中添加一个变量。

setenv()函数为形如 name=value 的字符串分配一块内存缓冲区，并将 name 和 value 所指
向的字符串复制到此缓冲区，以此来创建一个新的环境变量。注意，不需要（实际上，是绝
对不要）在 name 的结尾处或者 value 的开始处提供一个等号字符，因为 setenv()函数会在向环
境添加新变量时添加等号字符。
若以 name 标识的变量在环境中已经存在，且参数 overwrite 的值为 0，则 setenv()函数将
不改变环境，如果参数 overwrite 的值为非 0，则 setenv()函数总是改变环境。
这一事实—setenv()函数复制其参数（到环境中）—意味着与 putenv()函数不同，之后
对 name 和 value 所指字符串内容的修改将不会影响环境。此外，使用自动变量作为 setenv()
函数的参数也不会有任何问题。
unsetenv()函数从环境中移除由 name 参数标识的变量。

同 setenv()函数一样，参数 name 不应包含等号字符。
setenv()函数和 unsetenv()函数均来自 BSD，不如 putenv()函数使用普遍。


### 程序实例

```c
#define _GNU_SOURCE
#include "tlpi_hdr.h"
#include <stdlib.h>

extern char **environ;

int main(int argc, char *argv[]) {
    int j;
    char **ep;

    clearenv(); // 清除当前进程的环境变量

    for (j = 0; j < argc; j++) { // 遍历命令行参数
        if (putenv(argv[j]) != 0) { // 设置环境变量为命令行参数
            errExit("putenv:%s", argv[j]); // 如果设置失败，输出错误信息并退出程序
        }
    }

    if (setenv("GREET", "Hello world", 0) == -1) { // 设置环境变量"GREET"为"Hello world"
        errExit("setenv"); // 如果设置失败，输出错误信息并退出程序
    }

    unsetenv("BYE"); // 删除环境变量"BYE"

    for (ep = environ; *ep != NULL; ep++) { // 遍历环境变量数组
        puts(*ep); // 输出每个环境变量的值
    }

    exit(EXIT_SUCCESS); // 退出程序
}
```

## 执行非局部跳转：setjmp()和longjmp()

使用库函数 setjmp()和 longjmp()可执行非局部跳转（nonlocal goto）。术语“非局部（nonlocal）”
是指跳转的目标为当前执行函数之外的某个位置。
C 语言，像许多其他编程语言一样，包含 goto 语句。这就好比打开了潘多拉的魔盒。若
无止境的滥用，将使程序难以阅读和维护。不过偶尔也能一显身手，令程序更简单、更快速，
或是兼而有之。
C 语言的 goto 语句存在一个限制，即不能从当前函数跳转到另一函数。然而，偶尔还是
需要这一功能的。考虑错误处理中经常出现的如下场景：在一个深度嵌套的函数调用中发生
了错误，需要放弃当前任务，从多层函数调用中返回，并在较高层级的函数中继续执行（也
许甚至是在 main()中）。要做到这一点，可以让每个函数都返回一个状态值，由函数的调用者
检查并做相应处理。这一方法完全有效，而且，在许多情况下，是处理这类场景的理想方法。
然而，有时候如果能从嵌套函数调用中跳出，返回该函数的调用者之一（当前调用者或者调用者的调用者，等等），编码会更为简单。setjmp()和 longjmp()就提供了这一功能。

setjmp()调用为后续由 longjmp()调用执行的跳转确立了跳转目标。该目标正是程序发起
setjmp()调用的位置。从编程角度看来，调用 longjmp()函数后，看起来就和从第二次调用 setjmp()
返回时完全一样。通过查看 setjmp()返回的整数值，可以区分 setjmp 调用是初始返回还是第二
次“返回”。初始调用返回值为 0，后续“伪”返回的返回值为 longjmp()调用中 val 参数所指
定的任意值。通过对 val 参数使用不同值，能够区分出程序中跳转至同一目标的不同起跳位置。
如果指定 longjmp()函数的 val 参数值为 0，而 longjmp 函数对此又不做检查，就会导致模
拟 setjmp()时返回值为 0，如同初次调用 setjmp()函数返回时一样。出于这一原因，如果指定
val 参数值为 0，则 longjmp()调用实际会将其替换为 1。
这两个函数的入参 env 为成功实现跳转提供了黏合剂。setjmp()函数把当前进程环境的各种
信息保存到 env 参数中。调用 longjmp()时必须指定相同的 env 变量，以此来执行“伪”返回。
由于对 setjmp()函数和 longjmp()函数的调用分别位于不同函数（否则，使用简单的 goto 即可），
所以应该将 env 参数定义为全局变量，或者将 env 作为函数入参来传递，后一种做法较为少见。
调用 setjmp()时，env 除了存储当前进程的其他信息外，还保存了程序计数寄存器（指向
当前正在执行的机器语言指令）和栈指针寄存器（标记栈顶）的副本。这些信息能够使后续
的 longjmp()调用完成两个关键步骤的操作。
将发起 longjmp()调用的函数与之前调用 setjmp()的函数之间的函数栈帧从栈上剥离。
有时又将此过程称为“解开栈（unwinding the stack）”，这是通过将栈指针寄存器重置
为 env 参数内的保存值来实现的。
重置程序计数寄存器，使程序得以从初始的 setjmp()调用位置继续执行。同样，此功
能是通过 env 参数中的保存值（程序计数寄存器）来实现的。

### 程序实例

```c
#include "tlpi_hdr.h"
#include <setjmp.h>

static jmp_buf env; // 定义一个jmp_buf类型的全局变量env，用于保存跳转位置的信息

static void f2(void) { longjmp(env, 2); } // 定义一个函数f2，调用longjmp将程序跳转到setjmp处并传递参数2

static void f1(int argc) {
    if (argc == 1) {
        longjmp(env, 1); // 如果argc为1，则调用longjmp将程序跳转到setjmp处并传递参数1
    }
    f2(); // 否则调用函数f2()
}

int main(int argc, char *argv[]) {
    switch (setjmp(env)) { // 使用setjmp函数保存当前执行点的状态，并将env作为跳转目标的标识
    case 0: // 初始状态
        printf("Calling f1() after initial setjmp()\n"); // 打印消息
        f1(argc); // 调用f1函数
        break;

    case 1: // 当从f1中longjmp回来时
        printf("We jumped back from f1()"); // 打印消息
        break;

    case 2: // 当从f2中longjmp回来时
        printf("We jumped back from f2()"); // 打印消息
        break;
    }

    exit(EXIT_SUCCESS); // 退出程序
}
```

### 对setjump()函数的使用限制
1. 构成选择或迭代语句中的整个控制表达式
2. 作为一元操作符'!'的操作对象，最终表达式构成了选择或迭代语句的整个控制表达式。
3. 作为比较操作的一部分，另一个操作对象必须是一个整数常量表达式，且其最终表达式构成选择或迭代语句的整个控制表达式。
4.  作为独立的函数调用，且没有嵌入到更大的表达式之中。


注意：C 语言赋值语句不在上述列表之列。以下形式的语句是不符合标准的：
s = setjmp(env);
之所以规定这些限制，是因为作为常规函数的 setjmp()实现无法保证拥有足够信息来保存所
有寄存器值和封闭表达式中用到的临时栈位置，以便于在 longjmp()调用后此类信息能得以正确恢
复。因此，仅允许在足够简单且无需临时存储的表达式中调用 setjmp()。

### 滥用longjmp()

如果将 env 缓冲区定义为全局变量，对所有函数可见（这也是通常用法），那么就可以执
行如下操作序列。
1． 调用函数 x()，使用 setjmp()调用在全局变量 env 中建立一个跳转目标。
2． 从函数 x()中返回。
3． 调用函数 y()，使用 env 变量调用 longjmp()函数。
这是一个严重错误，因为 longjmp()调用不能跳转到一个已经返回的函数中。思考一下，
在这种情况下，longjmp()函数会对栈打什么主意—尝试将栈解开，恢复到一个不存在的栈
帧位置，这无疑将引起混乱。如果幸运的话，程序会一死（crash）了之。然而，取决于栈的
状态，也可能会引起调用与返回间的死循环，而程序好像真地从一个当前并未执行的函数中
返回了。（在多线程程序中有与之相类似的滥用，在线程某甲中调用 setjmp()函数，却在线程
某乙中调用 longjmp()。）

### 优化编译器的问题

优化编译器会重组程序的指令执行顺序，并在 CPU 寄存器中，而非 RAM 中存储某些变
量。这种优化一般依赖于反映了程序词法结构的运行时（run-time）控制流程。由于 setjmp()
和 longjmp()的跳转操作需在运行时才能得以确立和执行，并未在程序的词法结构中有所反映，
故而编译器在进行优化时也无法将其考虑在内。此外，某些应用程序二进制接口（ABI）实现
的语义要求 longjmp()函数恢复先前 setjmp()调用所保存的 CPU 寄存器副本。这意味着 longjmp()
操作会致使经过优化的变量被赋以错误值。

```c
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>

static jmp_buf env; // 定义了一个jmp_buf类型的全局变量env，用于保存跳转位置的信息

static void doJump(int nvar, int rvar, int vvar) {
    printf("Inside doJump(): nvar = %d rvar = %d vvar = %d\n", nvar, rvar,
           vvar);
    longjmp(env, 1); // 调用longjmp将程序跳转到setjmp处并传递参数1
}

int main(int argc, char *argv[]) {
    int nvar; // 自动变量
    register int rvar; // 寄存器变量
    volatile int vvar; // volatile变量

    nvar = 111; // 初始化自动变量
    rvar = 222; // 初始化寄存器变量
    vvar = 333; // 初始化volatile变量

    if (setjmp(env) == 0) { // 使用setjmp函数保存当前执行点的状态，并将env作为跳转目标的标识
        nvar = 777; // 修改自动变量
        rvar = 888; // 修改寄存器变量
        vvar = 999; // 修改volatile变量
        doJump(nvar, rvar, vvar); // 调用doJump函数
    } else { // 当从longjmp跳转回来时
        printf("After longjmp(): nvar = %d rvar = %d vvar = %d\n", nvar, rvar,
               vvar); // 打印各个变量的值
    }

    exit(EXIT_SUCCESS); // 退出程序
}
```

此处，在 longjmp()调用后，nvar 和 rvar 参数被重置为 setjmp()初次调用时的值。起因是
优化器对代码的重组受到 longjmp()调用的干扰。作为候选优化对象的任一局部变量可能都
难免会遇到这类问题，一般包含指针变量和 char、int、float、long 等任何简单类型的变量。
将变量声明为 volatile，是告诉优化器不要对其进行优化，从而避免了代码重组。在上面
的程序输出中，无论编译优化与否，声明为 volatile 的变量 vvar 都得到了正确处理。
因为不同的优化器有着不同的优化方法，具备良好移植性的程序应在调用 setjmp()的函数
中，将上述类型的所有局部变量都声明为 volatile。

### 尽可能避免使用 setjmp()函数和 longjmp()函数
如果说 goto 语句会使程序难以阅读，那么非局部跳转会让事情的糟糕程度增加一个数
量级，因为它能在程序中任意两个函数间传递控制。因此，应当慎用 setjmp()函数和 longjmp()
函数。在设计和编码时花点心思来避免使用这两个函数，这通常是值得的。